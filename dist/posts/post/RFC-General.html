<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/nextjs-github-pages/_next/static/css/bff8db8335876f50.css" as="style" crossorigin=""/><link rel="stylesheet" href="/nextjs-github-pages/_next/static/css/bff8db8335876f50.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/nextjs-github-pages/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/nextjs-github-pages/_next/static/chunks/webpack-a4f5812bb7f5b7f2.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/chunks/framework-5429a50ba5373c56.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/chunks/main-f79afddfaed1e50b.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/chunks/pages/_app-a4ac65f2b1f77632.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/chunks/855-affb66a2508f9c52.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/chunks/pages/posts/post/%5Bslug%5D-49000cd62d2003b4.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/8FBaA9tE3H2FwnNG4HFAa/_buildManifest.js" defer="" crossorigin=""></script><script src="/nextjs-github-pages/_next/static/8FBaA9tE3H2FwnNG4HFAa/_ssgManifest.js" defer="" crossorigin=""></script></head><body class=" bg-gray-100"><div id="__next"><div class="flex flex-col h-screen"><div class="w-full  bg-black"><div class="max-w-screen-xl mx-auto"><header class="flex items-center justify-between py-5  "><a class="px-2 text-xl lg:px-0 font-bold text-orange-400" href="/nextjs-github-pages">Github Blog</a><ul class="inline-flex items-center"><li class="px-2 md:px-4"><a class="text-white font-semibold hover:text-orange-500" href="/nextjs-github-pages"> Home </a></li><li class="px-2 md:px-4"><a class="text-white font-semibold hover:text-orange-500" href="/nextjs-github-pages/dev"> Developerment </a></li><li class="px-2 md:px-4"><a class="text-white font-semibold hover:text-orange-500" href="/nextjs-github-pages/htb"> HackTheBox </a></li><li class="px-2 md:px-4"><a class="text-white font-semibold hover:text-orange-500" href="/nextjs-github-pages/pentesting-web"> Pentesting Web </a></li></ul></header></div></div><main class="flex-grow"><div class="container mx-auto px-4"><h1 class="text-6xl text-center py-20 font-bold">Framework OAuth 2.0</h1><h5 class="text-xl text-center">En esta publicación sera descrito en forma resumida el Framework OAuth 2.0, el objetivo es identificar sus conceptos generales, como funciona el OAuth 2.0 y las consideraciones de seguridad. Toda la información que veras en esta publicación está basada en el RFC 6749. Los nombres de los roles y parámetros de OAuth están en inglés, la idea es hacer una descripción en español para facilitar la lectura del RFC.</h5><div></div><h6 class="text-center py-5">Publicado el <!-- -->8 de febrero de 2024</h6><h1 class="text-4xl text-center my-10 font-bold">¿Que es OAuth 2.0?</h1>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">OAuth 2.0 es un Framework que permite:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Gestionar los datos de los usuarios y la autorizacion de acceso a estos datos</li>
<li class="text-justify mx-2.5 hyphens-auto">Permite a los usuarios autenticarse en aplicaciones nativas o aplicaciones web  de terceros usando el protocolo HTTP.</li>
</ul>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Framework OAuth 2.0 define un conjunto de 4 posibles implementaciones o flujos de OAuth, estas son:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto"><a href="Authorization Code Grant" class="mdx-p inline-block mb-4 text-xs font-bold capitalize border-b-2 border-orange-600 hover:text-orange-600">Authorization Code Grant</a></li>
<li class="text-justify mx-2.5 hyphens-auto"><a href="Implicit Grant" class="mdx-p inline-block mb-4 text-xs font-bold capitalize border-b-2 border-orange-600 hover:text-orange-600">Implicit Grant</a></li>
<li class="text-justify mx-2.5 hyphens-auto"><a href="Resource Owner Password Credentials Grant" class="mdx-p inline-block mb-4 text-xs font-bold capitalize border-b-2 border-orange-600 hover:text-orange-600">Resource Owner Password Credentials Grant</a></li>
<li class="text-justify mx-2.5 hyphens-auto"><a href="Client Credentials Grant" class="mdx-p inline-block mb-4 text-xs font-bold capitalize border-b-2 border-orange-600 hover:text-orange-600">Client Credentials Grant</a></li>
</ul>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">De los flujos mencionados uno son mas seguros que otros. Sin embargo, OAuth no es una bala de plata, si tu sistema tiene otras vulnerabilidades como CSRF, XSS, Open Redirect, o el flujo o protocolo de OAuth es mal implementado, entonces tu sistema es vulnerable</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Te preguntaras, ¿qué es un flujo?: Un flujo en OAuth es un conjunto de interacciones entre las distintos &quot;roles&quot; del Framework. Define básicamente quien interactua con quien y como lo hace. Los &quot;roles&quot; mas importantes de OAuth son:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto"><strong>Resource Owner</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Resource Server</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Authorization Server</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Client</strong></li>
</ul>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Las interacciones de estos roles depende de &quot;parametros&quot; o &quot;tokens&quot; los cuales permiten intercambiar información entre los distintos roles del Framework OAuth, algunos de estos son:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto"><strong>Authorization Grant</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Access Token</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Authorization Code</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Implicit Authorization Grant</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>State</strong></li>
<li class="text-justify mx-2.5 hyphens-auto"><strong>Scope</strong></li>
<li class="text-justify mx-2.5 hyphens-auto">etc</li>
</ul>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">En el presente documento, veremos un Flow o flujo general del Framework OAuth 2.0 y describiremos sus role e interacciones</p>
<h1 class="text-4xl text-center my-10 font-bold">¿Cual es el proposito de OAuth 2.0?</h1>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El propósito de OAuth 2.0 es centralizar los datos de los usuarios, restringir el acceso a sus recursos y, además, permitir a otras aplicaciones (o aplicaciones de terceros) autenticar y validar la identidad de los usuarios que ingresan a sus sistemas</p>
<h1 class="text-4xl text-center my-10 font-bold">Conceptos importantes</h1>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">La siguiente lista son los conceptos esenciales para comprender OAuth 2.0</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Resource:</strong> Consiste en todo tipo de dato que pertenece a un usuario, por ejemplo: nombre, foto de perfil, email, numero de teléfono, dirección, etc.</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Resource Owner:</strong> Es el usuario dueño de sus datos, este comparte su información con el Resource Server. Además, es el que da autorización a otras aplicaciones  para acceder a sus datos almacenados en el Resource Server.</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Resource Server:</strong> Es el servidor que almacena los datos de todos los usuarios registrados en sus sistema. Estos datos estan protegidos y solo los usuarios o aplicaciones autorizadas pueden acceder a estos.</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Client:</strong> Es la aplicación nativa o web que intenta primero autenticar o registrar a un usuario  y, posteriormente acceder a ciertos datos o recursos del mismo.</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Authorization Server:</strong> Para acceder a los recursos de Resource Server el usuario (Resource Owner) debe autenticarse en el Authorization Server. Si el proceso de autenticación fue exitoso entonces, el Autorization Server emitira un <strong>Access Token</strong>. En resumidas cuentas, es el servidor que da acceso a los recursos del usuario a través del Access Token</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Authorization Grant:</strong> Es una credencial que representa la autorizacion que da un <strong>Resource Owner</strong> a un <strong>Client</strong> para acceder a sus recursos</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Access Token:</strong> Token que permite al <strong>Client</strong> el acceso a los recursos de <strong>Resource Owner</strong> almacenados en el <strong>Resource Server</strong></p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><strong>Client Credentials:</strong> Son las credenciales con las que el cliente se autentica con el Authorization Server</p>
</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Conceptos Utilizados en otros flujos de OAuth</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Flujo Authorization Code Grant:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto"><strong>Authorization Code:</strong> El Authorization Code es un  token que es obtenido de la interaccion entre el <strong>Client</strong> y el <strong>Authorization Server</strong>. Este forma parte del flujo <strong>Authorization Code Grant</strong>, De forma muy resumida el proceso para obtener el Authorization Code es siguiente:<!-- -->
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">En vez de solicitar autorizacion al <strong>Resource Server</strong>, el <strong>Client</strong> redirecciona al usuario (Resource Owner) al Authorization Server a través de un navegador web</li>
<li class="text-justify mx-2.5 hyphens-auto">El <strong>Authorization Server</strong> autentica al usuario (<strong>Resource Owner</strong>) este último autoriza al <strong>Client</strong> y luego el <strong>Authorization Server</strong> redirige al usuario a la pagina de cliente a través de un navegador web</li>
<li class="text-justify mx-2.5 hyphens-auto">Finalmente el <strong>Client</strong> envía el <strong>Authorization Code</strong>  al <strong>Authorization Server</strong> para obtener el <strong>Access Token</strong>, que pemitirá al cliente acceder a los recursos del usuario</li>
</ul>
</li>
</ul>
<h1 class="text-4xl text-center my-10 font-bold">Protocol Flow de OAuth 2.0</h1>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Protocol Flow permite ver las interacciones entre los distintos roles del Framework OAuth 2.0</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><img alt="" loading="lazy" width="400" height="200" decoding="async" data-nimg="1" style="color:transparent;width:auto;height:auto;margin-left:auto;margin-right:auto" src="/nextjs-github-pages/RFC-General/Pasted_image_20240214134004.png"/></p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(A) El <strong>Client</strong> solicita autorización al Resource Owner para acceder a sus recursos</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(B) El <strong>Resource Owner</strong> autoriza al cliente, el cual es reflejado en el <strong>Authorization Grant</strong>, este ultimo es la credenciales que representa la autorizacion del <strong>Resource Owner</strong></p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(C) El <strong>Cliente</strong> envía el <strong>Authorization Grant</strong> al <strong>Authorization Server</strong></p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(D) El <strong>Authorization Server</strong> valida el <strong>Authorization Grant</strong>, si es válido entrega un <strong>Access Token</strong> al cliente</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(E) El <strong>Client</strong> envía el <strong>Access Token</strong> al <strong>Resource Server</strong> para solicitar el acceso a uno o varios recursos del usuario (<strong>Resource Owner</strong>)</p>
</li>
<li class="text-justify mx-2.5 hyphens-auto">
<p class="mdx-p text-justify mx-2.5 hyphens-auto">(F) El <strong>Resource Server</strong> valida el Access Token, si es válido, entonces entrega los recursos solicitados</p>
</li>
</ul>
<h1 class="text-4xl text-center my-10 font-bold">Consideraciones de seguridad</h1>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">La siguiente lista es un conjunto de recomendaciones para mantener la seguridad del Framework OAuth 2.0. Estas pueden ser utilizadas tanto para mejorar la seguridad como para explotar la implementacion de OAuth (puede ser útil para alguna metodología de ataque a OAuth ;) ).</p>
<h2 class="text-2xl py-10 text-center font-bold">El Cliente Debe:</h2>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Mantener seguras sus credenciales, un cliente puede ser suplantado si no mantiene sus credenciales seguras</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Autentication Server debe:</h2>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Identificar al cliente mediante sus credenciales.</li>
<li class="text-justify mx-2.5 hyphens-auto">Mantener las credenciales del cliente seguras</li>
<li class="text-justify mx-2.5 hyphens-auto">No debe emitir las credenciales del cliente a aplicaciones nativas con el objetivo de autenticar al cliente</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server puede emitir las credenciales de cliente para aplicaciones nativas instaladas en dispositivos específicos.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usurio), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Suplantacion del Cliente</h2>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Si el Autorization Server no puede autenticar al cliente debido a su naturaleza, el Authorization Server debe requerir el registrar el Redirection URI para recibir Authorization Responses.</li>
<li class="text-justify mx-2.5 hyphens-auto">En caso de no poder autenticar al cliente o Identificarlo, el Authorization Server puede Consultar al Resource Owner.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe explicitamente autenticar al Resource Owner y entregar al resource Owner información sobre el cliente junto con el Request Authorization Scope y Lifetime.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usuario), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Access Token</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Access Token como cualquier atributo de éste, debe ser confidencial tanto en tránsito como en almacenamiento. Solo debe ser compartido con el Authorization Server y el Resource Server.</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">El Flujo Grant type, el acccess token puede ser transmitido en el fragment de la URI.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe asegurarse que el Access Token no pueda ser generado o adivinado.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Cliente debe solicitar un Access Token con el minimo scope</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe identificar al cliente para entregar el Access Token.</li>
<li class="text-justify mx-2.5 hyphens-auto">El scope entregado al cliente puede ser menor del solicitado</li>
<li class="text-justify mx-2.5 hyphens-auto">El Resource Server debe identificar que el Access Token  ha sido emitido por el Authorization Server</li>
<li class="text-justify mx-2.5 hyphens-auto">El Access Token debe ser transmitido sobre TLS</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Refresh Token</h2>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">El Refresh Token debe ser  confidencial tanto en su transito como en su almacenamiento.</li>
<li class="text-justify mx-2.5 hyphens-auto">Debe ser compartido solo entre el Authorization Server y el Cliente</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe mantener un enlace entre el Refresh Token y el cliente al que fue emitido.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Refresh Token debe ser transmitido sobre TLS</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe asegurar una relación  entre el Refresh Token y el cliente</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe detectar abusos en Refresh Token. Por ejemplo el Authorization Server puede emitir regularmente nuevos Access Token para el cliente e invalidar los antiguos, pero deben seguir almacenados en el Authorization Server por si existe alguna solicitud no autorizada.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe asegurarse que el Refresh Token no pueda ser generado o adivinado.</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Authorization Codes</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Authorization Code es una bearer Credential que verifica que el Resource Owner da acceso a un recurso solicitado por un cliente</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">La transmision del authorization Code debe ser mediante un canal seguro.</li>
<li class="text-justify mx-2.5 hyphens-auto">El cliente debe requerir el uso de TLS en su Redirection URI</li>
<li class="text-justify mx-2.5 hyphens-auto">Ya que el Authorization Code es transmitido vía user-aget (browser), este puede ser revelado por el historial de navegación o por el Header HTTP Referer.</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Code debe ser de vida corta</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Code debe ser de un solo uso</li>
<li class="text-justify mx-2.5 hyphens-auto">El caso de multiples intentos de acceso con un Authorization Code el Authorization Server debe restringir todos los Access Token asociados al Authorization Code comprometido.</li>
<li class="text-justify mx-2.5 hyphens-auto">El  Authorization Server  debe asegurarse que el Authorization Code fue imitido por un cliente no autenticado</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Authorization Code Redirection URI Manipulation</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Cuando el cliente solicita un Auhtorization Grant en el Flujo Authorization Grant Type, este puede enviar parámetro llamado &quot;redirect_uri&quot; junto con el Authorization Code.</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Un atacante puede manipular el parámetro &quot;redirect_uri&quot; y redirigir el tráfico a un servidor bajo su control</li>
</ul>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El proceso de ataque es el siguiente:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">Un atacante puede crear una cuenta en un cliente legitimo e iniciar un flujo.</li>
<li class="text-justify mx-2.5 hyphens-auto">Cuando el atacante es enviado al Authorization Server para obtener el Grant Access, el atacante puede modificar el &quot;redirect_uri&quot; con una URI bajo el control del atacante</li>
<li class="text-justify mx-2.5 hyphens-auto">El atacante puede entregar esta URI manipulada a un usuario legitimo para que el cliente tenga acceso a sus recursos.</li>
<li class="text-justify mx-2.5 hyphens-auto">Luego de que que el Authorization endpoint valide la request, confíe en el cliente y la request sea autorizada, el Resource Owner será redirigido a la URI bajo el control del atacante.</li>
<li class="text-justify mx-2.5 hyphens-auto">El atacante completa el Flujo de Authorization enviando el Authorization Code al cliente usando la URI original. El cliente intercambia el Authorization Code y el Access Token y enlaza estos con la cuenta del atacante, el cual ahora tiene acceso a los recursos del la victima.</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Resource Owner Password Credentials</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">A menudo el Resource Owner Credentials es utilizado para sistemas legacy o migraciones. Esto reduce la posibilidad de almacenas las credenciales en el cliente, y al mismo tiempo elimina la posibilidad de exponer las credenciales al cliente.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El flujo es el siguiente:</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><img alt="" loading="lazy" width="400" height="200" decoding="async" data-nimg="1" style="color:transparent;width:auto;height:auto;margin-left:auto;margin-right:auto" src="/nextjs-github-pages/RFC-General/Pasted_image_20220802180007.png"/></p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">El cliente puede abusar de las credenciales del Resource Owner.</li>
<li class="text-justify mx-2.5 hyphens-auto">El cliente puede exponer las credenciales del Resource Owner.</li>
<li class="text-justify mx-2.5 hyphens-auto">Como el Resource Owner no tiene control sobre el proceso de autorización, el Cliente puede obtener Access Tokens con un scope más amplio de lo normal</li>
<li class="text-justify mx-2.5 hyphens-auto">El Authorization Server debe considerar el scope y el lifetime del Access Token para este tipo de clientes.</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Request Confidentiality</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Los campos : Access Token, Refresh Token, Resource Owner Passwords y Client Credentials no deben ser transmitidos de forma clara
El campo : Authorization code no debería ser transmitido en forma clara</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Los campos state y scope no deben incluir información sensible del Resource Owner, ya que estos pueden ser transmitidos de forma insegura o almancenados de forma insegura.</p>
<h2 class="text-2xl py-10 text-center font-bold">Cross-Site Request Foregery</h2>
<h3 class="text-lg my-5 font-bold">CSRF contra Cliente</h3>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">CSRF en Oauth consiste en atacar la &quot;redirection_uri&quot; del cliente, permitiendo a un atacante ingresar su propio Authorization Code o Access Token esto puede provocar que el Cliente use el Access Token del atacante más que el de la victima (Guardar la información de la cuenta de la victima en un Protected Resource controlado por el atacante).</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El cliente debe implementar métodos de protección en el parámetro de &quot;redirection_uri&quot;. Este método consiste en agregar un parámetro state con valor como una cookie de sesión. El cliente debe usar el parámetro state al Authorization Server siempre que se haga un Authorization Request.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Una vez el Resource Owner aprueba el acceso al recurso, el Authoriaztion Server redirige al usuario de vuelta al cliente con el parámetro state. Este valor permitirá al cliente validar la request con el state previo.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El valor del parámetro State debe cumplir lo siguiente:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">No debe ser fácil adivinar su valor</li>
<li class="text-justify mx-2.5 hyphens-auto">Debe ser conocido por el cliente y el user-agent (browser)</li>
<li class="text-justify mx-2.5 hyphens-auto">Debe ser accesible solo por el cliente y el user-agent (browser), por ejemplo, protegido por el Same Origin Policy</li>
</ul>
<h3 class="text-lg my-5 font-bold">CSRF contra Authorization Server</h3>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Un ataque CSRF contra el Authorization Server puede provocar que un atacante obtenga autorización para un cliente malicioso sin el consentimiento del Resource Owner</p>
<h2 class="text-2xl py-10 text-center font-bold">Code Injection and Input Validation</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">Si los parámetros de entrada del sistema no son validados correctamente puede causar multiples vulnerabilidades, como exposición de información, ejecución remota de comandos, modificación de la lógica de la aplicación, ataques de denegación de servicios,etc.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Authorization Server debe sanitizar todos los paŕametros de entrada al sistema, en particular los siguientes parámetros:</p>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto">state</li>
<li class="text-justify mx-2.5 hyphens-auto">redirect_uri</li>
</ul>
<h2 class="text-2xl py-10 text-center font-bold">Open Redirectors</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">El Authorization Server, Authorization Endpoint y el Client Redirection Endpoint pueden ser configurado de forma impropia y provocar una vulnerabilidad open redirect.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">La vulnerabilidad Open Redirect consiste en la manipulación de un parámetro para redirigir el user-agent (browser) a una URL indicada. Open direcct puede ser usada para Ataques de Phishing, o hacer que un end-user visite sitios maliciosos.</p>
<p class="mdx-p text-justify mx-2.5 hyphens-auto">También si el Authoriazation Server permite al cliente registrar parte de la redirection_url, un atacante puede usar este como un open redirect que será operado por el cliente para construir una URL que pasará la validación del  Authorization Server pero que enviara un Authorization Code o Access Token al endpoint que está abajo el control del atacante.</p>
<h2 class="text-2xl py-10 text-center font-bold">Misuse Of Access Token To impersonate Resource Owner in Implicit</h2>
<p class="mdx-p text-justify mx-2.5 hyphens-auto"><img alt="" loading="lazy" width="400" height="200" decoding="async" data-nimg="1" style="color:transparent;width:auto;height:auto;margin-left:auto;margin-right:auto" src="/nextjs-github-pages/RFC-General/Pasted_image_20220802192348.png"/></p>
<h1 class="text-4xl text-center my-10 font-bold">Fuentes</h1>
<ul class=" ml-10 mdx-p text-justify mx-2.5 hyphens-auto list-disc">
<li class="text-justify mx-2.5 hyphens-auto"><a href="OAuth RFC" class="mdx-p inline-block mb-4 text-xs font-bold capitalize border-b-2 border-orange-600 hover:text-orange-600">OAuth RFC</a></li>
</ul></div></main><footer class="bg-white border-t border-l  "><div class="flex"><div class="w-full text-center p-1"><h6 class="font-semibold text-gray-700 mb-4">A Simple Github Blog - 2024</h6></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"markdownData":"{\"orig\":\"---\\ntitle: Framework OAuth 2.0 \\nsubtitle: En esta publicación sera descrito en forma resumida el Framework OAuth 2.0, el objetivo es identificar sus conceptos generales, como funciona el OAuth 2.0 y las consideraciones de seguridad. Toda la información que veras en esta publicación está basada en el RFC 6749. Los nombres de los roles y parámetros de OAuth están en inglés, la idea es hacer una descripción en español para facilitar la lectura del RFC.\\ndate: 2024-02-09\\ntags:\\n    - Pentesting Web\\n---\\n\\n# ¿Que es OAuth 2.0?\\n\\nOAuth 2.0 es un Framework que permite:\\n\\n- Gestionar los datos de los usuarios y la autorizacion de acceso a estos datos\\n- Permite a los usuarios autenticarse en aplicaciones nativas o aplicaciones web  de terceros usando el protocolo HTTP.\\n\\nEl Framework OAuth 2.0 define un conjunto de 4 posibles implementaciones o flujos de OAuth, estas son:\\n\\n- [Authorization Code Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1)\\n- [Implicit Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2)\\n- [Resource Owner Password Credentials Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3)\\n- [Client Credentials Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4)\\n\\nDe los flujos mencionados uno son mas seguros que otros. Sin embargo, OAuth no es una bala de plata, si tu sistema tiene otras vulnerabilidades como CSRF, XSS, Open Redirect, o el flujo o protocolo de OAuth es mal implementado, entonces tu sistema es vulnerable\\n\\nTe preguntaras, ¿qué es un flujo?: Un flujo en OAuth es un conjunto de interacciones entre las distintos \\\"roles\\\" del Framework. Define básicamente quien interactua con quien y como lo hace. Los \\\"roles\\\" mas importantes de OAuth son:\\n\\n- **Resource Owner**\\n- **Resource Server**\\n- **Authorization Server**\\n- **Client**\\n\\nLas interacciones de estos roles depende de \\\"parametros\\\" o \\\"tokens\\\" los cuales permiten intercambiar información entre los distintos roles del Framework OAuth, algunos de estos son:\\n\\n- **Authorization Grant**\\n- **Access Token**\\n- **Authorization Code**\\n- **Implicit Authorization Grant**\\n- **State**\\n- **Scope**\\n- etc\\n\\nEn el presente documento, veremos un Flow o flujo general del Framework OAuth 2.0 y describiremos sus role e interacciones\\n\\n# ¿Cual es el proposito de OAuth 2.0?\\n\\nEl propósito de OAuth 2.0 es centralizar los datos de los usuarios, restringir el acceso a sus recursos y, además, permitir a otras aplicaciones (o aplicaciones de terceros) autenticar y validar la identidad de los usuarios que ingresan a sus sistemas\\n\\n# Conceptos importantes\\n\\nLa siguiente lista son los conceptos esenciales para comprender OAuth 2.0\\n\\n- **Resource:** Consiste en todo tipo de dato que pertenece a un usuario, por ejemplo: nombre, foto de perfil, email, numero de teléfono, dirección, etc.\\n\\n- **Resource Owner:** Es el usuario dueño de sus datos, este comparte su información con el Resource Server. Además, es el que da autorización a otras aplicaciones  para acceder a sus datos almacenados en el Resource Server.\\n\\n- **Resource Server:** Es el servidor que almacena los datos de todos los usuarios registrados en sus sistema. Estos datos estan protegidos y solo los usuarios o aplicaciones autorizadas pueden acceder a estos.\\n\\n- **Client:** Es la aplicación nativa o web que intenta primero autenticar o registrar a un usuario  y, posteriormente acceder a ciertos datos o recursos del mismo.\\n\\n- **Authorization Server:** Para acceder a los recursos de Resource Server el usuario (Resource Owner) debe autenticarse en el Authorization Server. Si el proceso de autenticación fue exitoso entonces, el Autorization Server emitira un **Access Token**. En resumidas cuentas, es el servidor que da acceso a los recursos del usuario a través del Access Token\\n\\n- **Authorization Grant:** Es una credencial que representa la autorizacion que da un **Resource Owner** a un **Client** para acceder a sus recursos\\n\\n- **Access Token:** Token que permite al **Client** el acceso a los recursos de **Resource Owner** almacenados en el **Resource Server**\\n\\n- **Client Credentials:** Son las credenciales con las que el cliente se autentica con el Authorization Server\\n\\n## Conceptos Utilizados en otros flujos de OAuth\\n\\nFlujo Authorization Code Grant:\\n\\n- **Authorization Code:** El Authorization Code es un  token que es obtenido de la interaccion entre el **Client** y el **Authorization Server**. Este forma parte del flujo **Authorization Code Grant**, De forma muy resumida el proceso para obtener el Authorization Code es siguiente:\\n\\t- En vez de solicitar autorizacion al **Resource Server**, el **Client** redirecciona al usuario (Resource Owner) al Authorization Server a través de un navegador web\\n\\t- El **Authorization Server** autentica al usuario (**Resource Owner**) este último autoriza al **Client** y luego el **Authorization Server** redirige al usuario a la pagina de cliente a través de un navegador web\\n\\t- Finalmente el **Client** envía el **Authorization Code**  al **Authorization Server** para obtener el **Access Token**, que pemitirá al cliente acceder a los recursos del usuario \\n\\n\\n# Protocol Flow de OAuth 2.0\\n\\nEl Protocol Flow permite ver las interacciones entre los distintos roles del Framework OAuth 2.0\\n\\n![](/RFC-General/Pasted_image_20240214134004.png)\\n\\n- (A) El **Client** solicita autorización al Resource Owner para acceder a sus recursos \\n\\n- (B) El **Resource Owner** autoriza al cliente, el cual es reflejado en el **Authorization Grant**, este ultimo es la credenciales que representa la autorizacion del **Resource Owner**\\n\\n- (C) El **Cliente** envía el **Authorization Grant** al **Authorization Server**\\n\\n- (D) El **Authorization Server** valida el **Authorization Grant**, si es válido entrega un **Access Token** al cliente\\n\\n- (E) El **Client** envía el **Access Token** al **Resource Server** para solicitar el acceso a uno o varios recursos del usuario (**Resource Owner**)\\n\\n- (F) El **Resource Server** valida el Access Token, si es válido, entonces entrega los recursos solicitados\\n\\n# Consideraciones de seguridad\\n\\nLa siguiente lista es un conjunto de recomendaciones para mantener la seguridad del Framework OAuth 2.0. Estas pueden ser utilizadas tanto para mejorar la seguridad como para explotar la implementacion de OAuth (puede ser útil para alguna metodología de ataque a OAuth ;) ).\\n\\n\\n## El Cliente Debe:\\n\\n- Mantener seguras sus credenciales, un cliente puede ser suplantado si no mantiene sus credenciales seguras\\n\\n## Autentication Server debe:\\n\\n- Identificar al cliente mediante sus credenciales.\\n- Mantener las credenciales del cliente seguras\\n- No debe emitir las credenciales del cliente a aplicaciones nativas con el objetivo de autenticar al cliente\\n- El Authorization Server puede emitir las credenciales de cliente para aplicaciones nativas instaladas en dispositivos específicos.\\n- El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usurio), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.\\n\\n## Suplantacion del Cliente\\n\\n - Si el Autorization Server no puede autenticar al cliente debido a su naturaleza, el Authorization Server debe requerir el registrar el Redirection URI para recibir Authorization Responses.\\n- En caso de no poder autenticar al cliente o Identificarlo, el Authorization Server puede Consultar al Resource Owner.\\n- El Authorization Server debe explicitamente autenticar al Resource Owner y entregar al resource Owner información sobre el cliente junto con el Request Authorization Scope y Lifetime.\\n- El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usuario), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.\\n\\n## Access Token\\n\\nEl Access Token como cualquier atributo de éste, debe ser confidencial tanto en tránsito como en almacenamiento. Solo debe ser compartido con el Authorization Server y el Resource Server.\\n\\n- El Flujo Grant type, el acccess token puede ser transmitido en el fragment de la URI.\\n- El Authorization Server debe asegurarse que el Access Token no pueda ser generado o adivinado.\\n- El Cliente debe solicitar un Access Token con el minimo scope\\n- El Authorization Server debe identificar al cliente para entregar el Access Token.\\n- El scope entregado al cliente puede ser menor del solicitado\\n- El Resource Server debe identificar que el Access Token  ha sido emitido por el Authorization Server\\n- El Access Token debe ser transmitido sobre TLS\\n\\n## Refresh Token\\n\\n- El Refresh Token debe ser  confidencial tanto en su transito como en su almacenamiento.\\n- Debe ser compartido solo entre el Authorization Server y el Cliente\\n- El Authorization Server debe mantener un enlace entre el Refresh Token y el cliente al que fue emitido.\\n- El Refresh Token debe ser transmitido sobre TLS\\n- El Authorization Server debe asegurar una relación  entre el Refresh Token y el cliente\\n- El Authorization Server debe detectar abusos en Refresh Token. Por ejemplo el Authorization Server puede emitir regularmente nuevos Access Token para el cliente e invalidar los antiguos, pero deben seguir almacenados en el Authorization Server por si existe alguna solicitud no autorizada.\\n- El Authorization Server debe asegurarse que el Refresh Token no pueda ser generado o adivinado.\\n\\n## Authorization Codes\\n\\nEl Authorization Code es una bearer Credential que verifica que el Resource Owner da acceso a un recurso solicitado por un cliente \\n\\n- La transmision del authorization Code debe ser mediante un canal seguro.\\n- El cliente debe requerir el uso de TLS en su Redirection URI\\n- Ya que el Authorization Code es transmitido vía user-aget (browser), este puede ser revelado por el historial de navegación o por el Header HTTP Referer.\\n- El Authorization Code debe ser de vida corta\\n- El Authorization Code debe ser de un solo uso\\n- El caso de multiples intentos de acceso con un Authorization Code el Authorization Server debe restringir todos los Access Token asociados al Authorization Code comprometido.\\n- El  Authorization Server  debe asegurarse que el Authorization Code fue imitido por un cliente no autenticado\\n\\n## Authorization Code Redirection URI Manipulation\\n\\nCuando el cliente solicita un Auhtorization Grant en el Flujo Authorization Grant Type, este puede enviar parámetro llamado \\\"redirect_uri\\\" junto con el Authorization Code. \\n\\n- Un atacante puede manipular el parámetro \\\"redirect_uri\\\" y redirigir el tráfico a un servidor bajo su control\\n\\nEl proceso de ataque es el siguiente:\\n\\n- Un atacante puede crear una cuenta en un cliente legitimo e iniciar un flujo. \\n- Cuando el atacante es enviado al Authorization Server para obtener el Grant Access, el atacante puede modificar el \\\"redirect_uri\\\" con una URI bajo el control del atacante \\n- El atacante puede entregar esta URI manipulada a un usuario legitimo para que el cliente tenga acceso a sus recursos. \\n- Luego de que que el Authorization endpoint valide la request, confíe en el cliente y la request sea autorizada, el Resource Owner será redirigido a la URI bajo el control del atacante. \\n- El atacante completa el Flujo de Authorization enviando el Authorization Code al cliente usando la URI original. El cliente intercambia el Authorization Code y el Access Token y enlaza estos con la cuenta del atacante, el cual ahora tiene acceso a los recursos del la victima.\\n\\n## Resource Owner Password Credentials\\n\\nA menudo el Resource Owner Credentials es utilizado para sistemas legacy o migraciones. Esto reduce la posibilidad de almacenas las credenciales en el cliente, y al mismo tiempo elimina la posibilidad de exponer las credenciales al cliente.\\n\\nEl flujo es el siguiente:\\n\\n![](/RFC-General/Pasted_image_20220802180007.png)\\n\\n- El cliente puede abusar de las credenciales del Resource Owner.\\n- El cliente puede exponer las credenciales del Resource Owner.\\n- Como el Resource Owner no tiene control sobre el proceso de autorización, el Cliente puede obtener Access Tokens con un scope más amplio de lo normal\\n- El Authorization Server debe considerar el scope y el lifetime del Access Token para este tipo de clientes. \\n\\n\\n## Request Confidentiality\\n\\nLos campos : Access Token, Refresh Token, Resource Owner Passwords y Client Credentials no deben ser transmitidos de forma clara\\nEl campo : Authorization code no debería ser transmitido en forma clara\\n\\nLos campos state y scope no deben incluir información sensible del Resource Owner, ya que estos pueden ser transmitidos de forma insegura o almancenados de forma insegura.\\n\\n\\n## Cross-Site Request Foregery\\n\\n### CSRF contra Cliente\\n\\nCSRF en Oauth consiste en atacar la \\\"redirection_uri\\\" del cliente, permitiendo a un atacante ingresar su propio Authorization Code o Access Token esto puede provocar que el Cliente use el Access Token del atacante más que el de la victima (Guardar la información de la cuenta de la victima en un Protected Resource controlado por el atacante).\\n\\nEl cliente debe implementar métodos de protección en el parámetro de \\\"redirection_uri\\\". Este método consiste en agregar un parámetro state con valor como una cookie de sesión. El cliente debe usar el parámetro state al Authorization Server siempre que se haga un Authorization Request.\\n\\nUna vez el Resource Owner aprueba el acceso al recurso, el Authoriaztion Server redirige al usuario de vuelta al cliente con el parámetro state. Este valor permitirá al cliente validar la request con el state previo.\\n\\nEl valor del parámetro State debe cumplir lo siguiente:\\n\\n- No debe ser fácil adivinar su valor\\n- Debe ser conocido por el cliente y el user-agent (browser)\\n- Debe ser accesible solo por el cliente y el user-agent (browser), por ejemplo, protegido por el Same Origin Policy\\n\\n### CSRF contra Authorization Server\\n\\nUn ataque CSRF contra el Authorization Server puede provocar que un atacante obtenga autorización para un cliente malicioso sin el consentimiento del Resource Owner \\n\\n## Code Injection and Input Validation\\n\\nSi los parámetros de entrada del sistema no son validados correctamente puede causar multiples vulnerabilidades, como exposición de información, ejecución remota de comandos, modificación de la lógica de la aplicación, ataques de denegación de servicios,etc.\\n\\nEl Authorization Server debe sanitizar todos los paŕametros de entrada al sistema, en particular los siguientes parámetros:\\n\\n- state\\n- redirect_uri\\n\\n## Open Redirectors\\n\\nEl Authorization Server, Authorization Endpoint y el Client Redirection Endpoint pueden ser configurado de forma impropia y provocar una vulnerabilidad open redirect.\\n\\nLa vulnerabilidad Open Redirect consiste en la manipulación de un parámetro para redirigir el user-agent (browser) a una URL indicada. Open direcct puede ser usada para Ataques de Phishing, o hacer que un end-user visite sitios maliciosos.\\n\\nTambién si el Authoriazation Server permite al cliente registrar parte de la redirection_url, un atacante puede usar este como un open redirect que será operado por el cliente para construir una URL que pasará la validación del  Authorization Server pero que enviara un Authorization Code o Access Token al endpoint que está abajo el control del atacante.\\n\\n\\n## Misuse Of Access Token To impersonate Resource Owner in Implicit\\n\\n![](/RFC-General/Pasted_image_20220802192348.png)\\n\\n# Fuentes\\n\\n\\n- [OAuth RFC](https://datatracker.ietf.org/doc/html/rfc6749#section-10)\",\"data\":{\"title\":\"Framework OAuth 2.0\",\"subtitle\":\"En esta publicación sera descrito en forma resumida el Framework OAuth 2.0, el objetivo es identificar sus conceptos generales, como funciona el OAuth 2.0 y las consideraciones de seguridad. Toda la información que veras en esta publicación está basada en el RFC 6749. Los nombres de los roles y parámetros de OAuth están en inglés, la idea es hacer una descripción en español para facilitar la lectura del RFC.\",\"date\":\"2024-02-09T00:00:00.000Z\",\"tags\":[\"Pentesting Web\"]},\"content\":\"\\n# ¿Que es OAuth 2.0?\\n\\nOAuth 2.0 es un Framework que permite:\\n\\n- Gestionar los datos de los usuarios y la autorizacion de acceso a estos datos\\n- Permite a los usuarios autenticarse en aplicaciones nativas o aplicaciones web  de terceros usando el protocolo HTTP.\\n\\nEl Framework OAuth 2.0 define un conjunto de 4 posibles implementaciones o flujos de OAuth, estas son:\\n\\n- [Authorization Code Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.1)\\n- [Implicit Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.2)\\n- [Resource Owner Password Credentials Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3)\\n- [Client Credentials Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4)\\n\\nDe los flujos mencionados uno son mas seguros que otros. Sin embargo, OAuth no es una bala de plata, si tu sistema tiene otras vulnerabilidades como CSRF, XSS, Open Redirect, o el flujo o protocolo de OAuth es mal implementado, entonces tu sistema es vulnerable\\n\\nTe preguntaras, ¿qué es un flujo?: Un flujo en OAuth es un conjunto de interacciones entre las distintos \\\"roles\\\" del Framework. Define básicamente quien interactua con quien y como lo hace. Los \\\"roles\\\" mas importantes de OAuth son:\\n\\n- **Resource Owner**\\n- **Resource Server**\\n- **Authorization Server**\\n- **Client**\\n\\nLas interacciones de estos roles depende de \\\"parametros\\\" o \\\"tokens\\\" los cuales permiten intercambiar información entre los distintos roles del Framework OAuth, algunos de estos son:\\n\\n- **Authorization Grant**\\n- **Access Token**\\n- **Authorization Code**\\n- **Implicit Authorization Grant**\\n- **State**\\n- **Scope**\\n- etc\\n\\nEn el presente documento, veremos un Flow o flujo general del Framework OAuth 2.0 y describiremos sus role e interacciones\\n\\n# ¿Cual es el proposito de OAuth 2.0?\\n\\nEl propósito de OAuth 2.0 es centralizar los datos de los usuarios, restringir el acceso a sus recursos y, además, permitir a otras aplicaciones (o aplicaciones de terceros) autenticar y validar la identidad de los usuarios que ingresan a sus sistemas\\n\\n# Conceptos importantes\\n\\nLa siguiente lista son los conceptos esenciales para comprender OAuth 2.0\\n\\n- **Resource:** Consiste en todo tipo de dato que pertenece a un usuario, por ejemplo: nombre, foto de perfil, email, numero de teléfono, dirección, etc.\\n\\n- **Resource Owner:** Es el usuario dueño de sus datos, este comparte su información con el Resource Server. Además, es el que da autorización a otras aplicaciones  para acceder a sus datos almacenados en el Resource Server.\\n\\n- **Resource Server:** Es el servidor que almacena los datos de todos los usuarios registrados en sus sistema. Estos datos estan protegidos y solo los usuarios o aplicaciones autorizadas pueden acceder a estos.\\n\\n- **Client:** Es la aplicación nativa o web que intenta primero autenticar o registrar a un usuario  y, posteriormente acceder a ciertos datos o recursos del mismo.\\n\\n- **Authorization Server:** Para acceder a los recursos de Resource Server el usuario (Resource Owner) debe autenticarse en el Authorization Server. Si el proceso de autenticación fue exitoso entonces, el Autorization Server emitira un **Access Token**. En resumidas cuentas, es el servidor que da acceso a los recursos del usuario a través del Access Token\\n\\n- **Authorization Grant:** Es una credencial que representa la autorizacion que da un **Resource Owner** a un **Client** para acceder a sus recursos\\n\\n- **Access Token:** Token que permite al **Client** el acceso a los recursos de **Resource Owner** almacenados en el **Resource Server**\\n\\n- **Client Credentials:** Son las credenciales con las que el cliente se autentica con el Authorization Server\\n\\n## Conceptos Utilizados en otros flujos de OAuth\\n\\nFlujo Authorization Code Grant:\\n\\n- **Authorization Code:** El Authorization Code es un  token que es obtenido de la interaccion entre el **Client** y el **Authorization Server**. Este forma parte del flujo **Authorization Code Grant**, De forma muy resumida el proceso para obtener el Authorization Code es siguiente:\\n\\t- En vez de solicitar autorizacion al **Resource Server**, el **Client** redirecciona al usuario (Resource Owner) al Authorization Server a través de un navegador web\\n\\t- El **Authorization Server** autentica al usuario (**Resource Owner**) este último autoriza al **Client** y luego el **Authorization Server** redirige al usuario a la pagina de cliente a través de un navegador web\\n\\t- Finalmente el **Client** envía el **Authorization Code**  al **Authorization Server** para obtener el **Access Token**, que pemitirá al cliente acceder a los recursos del usuario \\n\\n\\n# Protocol Flow de OAuth 2.0\\n\\nEl Protocol Flow permite ver las interacciones entre los distintos roles del Framework OAuth 2.0\\n\\n![](/RFC-General/Pasted_image_20240214134004.png)\\n\\n- (A) El **Client** solicita autorización al Resource Owner para acceder a sus recursos \\n\\n- (B) El **Resource Owner** autoriza al cliente, el cual es reflejado en el **Authorization Grant**, este ultimo es la credenciales que representa la autorizacion del **Resource Owner**\\n\\n- (C) El **Cliente** envía el **Authorization Grant** al **Authorization Server**\\n\\n- (D) El **Authorization Server** valida el **Authorization Grant**, si es válido entrega un **Access Token** al cliente\\n\\n- (E) El **Client** envía el **Access Token** al **Resource Server** para solicitar el acceso a uno o varios recursos del usuario (**Resource Owner**)\\n\\n- (F) El **Resource Server** valida el Access Token, si es válido, entonces entrega los recursos solicitados\\n\\n# Consideraciones de seguridad\\n\\nLa siguiente lista es un conjunto de recomendaciones para mantener la seguridad del Framework OAuth 2.0. Estas pueden ser utilizadas tanto para mejorar la seguridad como para explotar la implementacion de OAuth (puede ser útil para alguna metodología de ataque a OAuth ;) ).\\n\\n\\n## El Cliente Debe:\\n\\n- Mantener seguras sus credenciales, un cliente puede ser suplantado si no mantiene sus credenciales seguras\\n\\n## Autentication Server debe:\\n\\n- Identificar al cliente mediante sus credenciales.\\n- Mantener las credenciales del cliente seguras\\n- No debe emitir las credenciales del cliente a aplicaciones nativas con el objetivo de autenticar al cliente\\n- El Authorization Server puede emitir las credenciales de cliente para aplicaciones nativas instaladas en dispositivos específicos.\\n- El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usurio), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.\\n\\n## Suplantacion del Cliente\\n\\n - Si el Autorization Server no puede autenticar al cliente debido a su naturaleza, el Authorization Server debe requerir el registrar el Redirection URI para recibir Authorization Responses.\\n- En caso de no poder autenticar al cliente o Identificarlo, el Authorization Server puede Consultar al Resource Owner.\\n- El Authorization Server debe explicitamente autenticar al Resource Owner y entregar al resource Owner información sobre el cliente junto con el Request Authorization Scope y Lifetime.\\n- El Authorization server no debe procesar Authorization request que se repiten de forma automatica (sin la interacción del usuario), sin autenticar al cliente o identificar que las request vienen desde un cliente legítimo.\\n\\n## Access Token\\n\\nEl Access Token como cualquier atributo de éste, debe ser confidencial tanto en tránsito como en almacenamiento. Solo debe ser compartido con el Authorization Server y el Resource Server.\\n\\n- El Flujo Grant type, el acccess token puede ser transmitido en el fragment de la URI.\\n- El Authorization Server debe asegurarse que el Access Token no pueda ser generado o adivinado.\\n- El Cliente debe solicitar un Access Token con el minimo scope\\n- El Authorization Server debe identificar al cliente para entregar el Access Token.\\n- El scope entregado al cliente puede ser menor del solicitado\\n- El Resource Server debe identificar que el Access Token  ha sido emitido por el Authorization Server\\n- El Access Token debe ser transmitido sobre TLS\\n\\n## Refresh Token\\n\\n- El Refresh Token debe ser  confidencial tanto en su transito como en su almacenamiento.\\n- Debe ser compartido solo entre el Authorization Server y el Cliente\\n- El Authorization Server debe mantener un enlace entre el Refresh Token y el cliente al que fue emitido.\\n- El Refresh Token debe ser transmitido sobre TLS\\n- El Authorization Server debe asegurar una relación  entre el Refresh Token y el cliente\\n- El Authorization Server debe detectar abusos en Refresh Token. Por ejemplo el Authorization Server puede emitir regularmente nuevos Access Token para el cliente e invalidar los antiguos, pero deben seguir almacenados en el Authorization Server por si existe alguna solicitud no autorizada.\\n- El Authorization Server debe asegurarse que el Refresh Token no pueda ser generado o adivinado.\\n\\n## Authorization Codes\\n\\nEl Authorization Code es una bearer Credential que verifica que el Resource Owner da acceso a un recurso solicitado por un cliente \\n\\n- La transmision del authorization Code debe ser mediante un canal seguro.\\n- El cliente debe requerir el uso de TLS en su Redirection URI\\n- Ya que el Authorization Code es transmitido vía user-aget (browser), este puede ser revelado por el historial de navegación o por el Header HTTP Referer.\\n- El Authorization Code debe ser de vida corta\\n- El Authorization Code debe ser de un solo uso\\n- El caso de multiples intentos de acceso con un Authorization Code el Authorization Server debe restringir todos los Access Token asociados al Authorization Code comprometido.\\n- El  Authorization Server  debe asegurarse que el Authorization Code fue imitido por un cliente no autenticado\\n\\n## Authorization Code Redirection URI Manipulation\\n\\nCuando el cliente solicita un Auhtorization Grant en el Flujo Authorization Grant Type, este puede enviar parámetro llamado \\\"redirect_uri\\\" junto con el Authorization Code. \\n\\n- Un atacante puede manipular el parámetro \\\"redirect_uri\\\" y redirigir el tráfico a un servidor bajo su control\\n\\nEl proceso de ataque es el siguiente:\\n\\n- Un atacante puede crear una cuenta en un cliente legitimo e iniciar un flujo. \\n- Cuando el atacante es enviado al Authorization Server para obtener el Grant Access, el atacante puede modificar el \\\"redirect_uri\\\" con una URI bajo el control del atacante \\n- El atacante puede entregar esta URI manipulada a un usuario legitimo para que el cliente tenga acceso a sus recursos. \\n- Luego de que que el Authorization endpoint valide la request, confíe en el cliente y la request sea autorizada, el Resource Owner será redirigido a la URI bajo el control del atacante. \\n- El atacante completa el Flujo de Authorization enviando el Authorization Code al cliente usando la URI original. El cliente intercambia el Authorization Code y el Access Token y enlaza estos con la cuenta del atacante, el cual ahora tiene acceso a los recursos del la victima.\\n\\n## Resource Owner Password Credentials\\n\\nA menudo el Resource Owner Credentials es utilizado para sistemas legacy o migraciones. Esto reduce la posibilidad de almacenas las credenciales en el cliente, y al mismo tiempo elimina la posibilidad de exponer las credenciales al cliente.\\n\\nEl flujo es el siguiente:\\n\\n![](/RFC-General/Pasted_image_20220802180007.png)\\n\\n- El cliente puede abusar de las credenciales del Resource Owner.\\n- El cliente puede exponer las credenciales del Resource Owner.\\n- Como el Resource Owner no tiene control sobre el proceso de autorización, el Cliente puede obtener Access Tokens con un scope más amplio de lo normal\\n- El Authorization Server debe considerar el scope y el lifetime del Access Token para este tipo de clientes. \\n\\n\\n## Request Confidentiality\\n\\nLos campos : Access Token, Refresh Token, Resource Owner Passwords y Client Credentials no deben ser transmitidos de forma clara\\nEl campo : Authorization code no debería ser transmitido en forma clara\\n\\nLos campos state y scope no deben incluir información sensible del Resource Owner, ya que estos pueden ser transmitidos de forma insegura o almancenados de forma insegura.\\n\\n\\n## Cross-Site Request Foregery\\n\\n### CSRF contra Cliente\\n\\nCSRF en Oauth consiste en atacar la \\\"redirection_uri\\\" del cliente, permitiendo a un atacante ingresar su propio Authorization Code o Access Token esto puede provocar que el Cliente use el Access Token del atacante más que el de la victima (Guardar la información de la cuenta de la victima en un Protected Resource controlado por el atacante).\\n\\nEl cliente debe implementar métodos de protección en el parámetro de \\\"redirection_uri\\\". Este método consiste en agregar un parámetro state con valor como una cookie de sesión. El cliente debe usar el parámetro state al Authorization Server siempre que se haga un Authorization Request.\\n\\nUna vez el Resource Owner aprueba el acceso al recurso, el Authoriaztion Server redirige al usuario de vuelta al cliente con el parámetro state. Este valor permitirá al cliente validar la request con el state previo.\\n\\nEl valor del parámetro State debe cumplir lo siguiente:\\n\\n- No debe ser fácil adivinar su valor\\n- Debe ser conocido por el cliente y el user-agent (browser)\\n- Debe ser accesible solo por el cliente y el user-agent (browser), por ejemplo, protegido por el Same Origin Policy\\n\\n### CSRF contra Authorization Server\\n\\nUn ataque CSRF contra el Authorization Server puede provocar que un atacante obtenga autorización para un cliente malicioso sin el consentimiento del Resource Owner \\n\\n## Code Injection and Input Validation\\n\\nSi los parámetros de entrada del sistema no son validados correctamente puede causar multiples vulnerabilidades, como exposición de información, ejecución remota de comandos, modificación de la lógica de la aplicación, ataques de denegación de servicios,etc.\\n\\nEl Authorization Server debe sanitizar todos los paŕametros de entrada al sistema, en particular los siguientes parámetros:\\n\\n- state\\n- redirect_uri\\n\\n## Open Redirectors\\n\\nEl Authorization Server, Authorization Endpoint y el Client Redirection Endpoint pueden ser configurado de forma impropia y provocar una vulnerabilidad open redirect.\\n\\nLa vulnerabilidad Open Redirect consiste en la manipulación de un parámetro para redirigir el user-agent (browser) a una URL indicada. Open direcct puede ser usada para Ataques de Phishing, o hacer que un end-user visite sitios maliciosos.\\n\\nTambién si el Authoriazation Server permite al cliente registrar parte de la redirection_url, un atacante puede usar este como un open redirect que será operado por el cliente para construir una URL que pasará la validación del  Authorization Server pero que enviara un Authorization Code o Access Token al endpoint que está abajo el control del atacante.\\n\\n\\n## Misuse Of Access Token To impersonate Resource Owner in Implicit\\n\\n![](/RFC-General/Pasted_image_20220802192348.png)\\n\\n# Fuentes\\n\\n\\n- [OAuth RFC](https://datatracker.ietf.org/doc/html/rfc6749#section-10)\"}"},"__N_SSG":true},"page":"/posts/post/[slug]","query":{"slug":"RFC-General"},"buildId":"8FBaA9tE3H2FwnNG4HFAa","assetPrefix":"/nextjs-github-pages","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>